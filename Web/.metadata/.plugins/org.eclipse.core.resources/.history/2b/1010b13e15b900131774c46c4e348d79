<?php

require_once 'config.php';
require_once 'WebSocket.php';

/**
 * Represents a client connected to the socket server.
 * @author Kenan Kigunda
 */
class Client {
	/**
	 * The client connection.
	 * @var resource
	 */
	private $connection;

	/**
	 * The type of client, either 'r' for rover or 'p' for player
	 * @var string
	 */
	private $type;

	/**
	 * The ID of the client.
	 * @var integer
	 */
	private $id;

	/**
	 * The ID specifying where communications to and from the client will be logged
	 * @var unknown
	 */
	private $logId;

	/**
	 * The clients being currently connected to this server.
	 * @var Client[]
	 */
	public static $CLIENTS = array();

	/**
	 * The index of this client in the clients array.
	 * @var integer
	*/
	private $index;

	/**
	 * The websocket used by this client.
	 * Null if this client is not using websocket.
	 * @var Websocket
	 */
	private $websocket;

	// CONSTRUCTION

	/**
	 * Creates a new client.
	 * @param resource $connection the client connection
	 * @param integer $logId the ID specifying where communications
	 * to and from the client will be logged
	 */
	public function __construct($connection, $logId) {
		$this->connection = $connection;
		$this->type = null;
		$this->id = null;
		$this->logId = $logId;
		$this->index = Client::getNextIndex();
	}

	/**
	 * Gets the index of the next client in the client list
	 * @return number the index of the next client
	 */
	private static function getNextIndex() {
		if (count(Client::$CLIENTS) > 0) {
			return max(array_keys(Client::$CLIENTS)) + 1;
		} else {
			return 0;
		}
	}

	/**
	 * Adds a new client on the given connection.
	 * @param resource $connection the client's socket connection
	 */
	public static function add($connection) {
		global $db;
		// Create the connection log.
		$stmt = $db->query("INSERT INTO connection VALUES ();");
		$logId = $db->lastInsertId();
		// Create the new client.
		Client::$CLIENTS[] = new Client($connection, $logId);
	}

	// WEBSOCKET

	/**
	 * Sets up this client to communicate with websocket.
	 */
	public function useWebsocket() {
		$this->websocket = new Websocket($this);
		$this->websocket->handshake();
	}

	// CLIENT DETAILS

	/**
	 * Indicates whether this client's details are set.
	 * The details are set from a "+" declaration that should be sent
	 * when the client first connects.
	 * To set the details, pass the declaration to setDetails().
	 * @return boolean true if the client details are set
	 */
	public function hasDetails() {
		return $this->type != null;
	}

	/**
	 * Sets the details of this client, such as its type and ID.
	 * @param string $declaration the declaration giving the client details
	 */
	public function setDetails($declaration) {
		// Set the details.
		$this->type = $declaration[1];
		$this->id = $declaration[2];
		// Send the confirmation to the client.
		$this->write(ARCAP_OK);
		// Send rover confirmation to the connected player.
		
		foreach (Client::$CLIENTS as $client) {
			if (($client->type == "p") && ($client->id == $this->id)) {
				$client->write(ARCAP_OK);
			}
		}
	}

	/**
	 * Confirms that the details given match the current details of this client, such as its type and ID.
	 * The client will write ARCAP_OK if the details match its current details;
	 * if they do not, the client will write ARCAP_ERR.
	 * @param string $details the declaration giving the client details
	 */
	public function confirmDetails($declaration) {
		$match = ($this->type == $declaration[1]) && ($this->id == $declaration[2]);
		if ($match) {
			$this->write(ARCAP_OK);
		} else {
			$this->write(ARCAP_ERR);
		}
	}

	/**
	 * Returns the details of this client, such as its type and ID.
	 * @return string the client details
	 */
	public function getDetails() {
		return ARCAP_COMMAND_PREFIX . "client:{$this->type}{$this->id}:{$this->index}";
	}

	// COMMUNICATIONS

	/**
	 * Reads from this connection.
	 * @return string the message read, or null if the message could not be read
	 */
	public function read() {
		if ($this->websocket) {
			if ($this->websocket->hasHandshaked()) {
				// For websocket data, use receive and unmask the data.
				$numBytes = socket_recv($this->connection, $data, ARCAP_WEBSOCKET_MAX_READ_LENGTH, 0);
				return $this->websocket->unmask($data);
			} else {
				// For websocket handshake, use default read.
				return socket_read($this->connection, ARCAP_WEBSOCKET_MAX_READ_LENGTH);
			}
		} else {
			// For regular sockets, use normal read.
			return socket_read($this->connection, ARCAP_SERVER_MAX_READ_LENGTH, PHP_NORMAL_READ);
		}
	}

	/**
	 * Writes the given message to this client.
	 * @param string $message the message to send
	 * @param string $stop the character marking the end of the message
	 */
	public function write($message, $stop = "\n") {
		$this->log($message);
		// Add the stop character.
		$message .= $stop;
		// Check if we should mask for websocket.
		if (($this->websocket) && ($this->websocket->hasHandshaked())) {
			$message = $this->websocket->mask($message);
		}
		// Write the message.
		socket_write($this->connection, $message, strlen($message));
	}

	/**
	 * Logs the given message to this client's log.
	 * @param string $message the message to log
	 */
	public function log($message) {
		global $db;
		echo $message . "\n";
		$stmt = $db->prepare("UPDATE connection ".
				"SET log = concat_ws(' ', log, :message) ".
				"WHERE id = :id;");
		$stmt->execute(array(":id" => $this->logId, ":message" => $message));
	}

	/**
	 * Handles the given event.
	 * @param string $event the name of the event
	 */
	public function handle($event) {
		if ($this->type == "r") {
			// Rovers:
			if ($event == "ih") {
				// Forward the infrared hit to all player clients.
				$response = file_get_contents("http://localhost/arcap/infrared/hit.php");
				$this->write(($response === false)? ARCAP_ERR : ARCAP_OK);
				foreach (Client::$CLIENTS as $client) {
					if ($client->type == "p") {
						$client->write("$event $this->id");
					}
				}
			} else {
				// Event not recognized; error.
				$this->write(ARCAP_ERR);
			}
		} else if ($this->type == "p") {
			// Players:
			// Forward the event to the matching rover client.
			$status = ARCAP_ERR;
			foreach (Client::$CLIENTS as $client) {
				if (($client->type == "r") && ($client->id == $this->id)) {
					$client->write($event);
					$status = ARCAP_OK;
				}
			} $this->write($status);
		} else {
			// Type not recognized; error.
			$this->write(ARCAP_ERR);
		}
	}

	/**
	 * Returns the last socket error associated with this client.
	 * @return string the last error
	 */
	public function error() {
		return socket_strerror(socket_last_error($this->connection));
	}

	/**
	 * Closes the connection to this client.
	 */
	public function close() {
		socket_close($this->connection);
		unset(Client::$CLIENTS[$this->index]);
	}

	// WAtCHING CONNECTIONS

	/**
	 * Indicates whether this client's connection is in the given array of connections.
	 * @param array $connections the haystack connections
	 * @return boolean true if this client's connection is in the haystack
	 */
	public function connectionIn(array $connections) {
		return in_array($this->connection, $connections);
	}

	/**
	 * Gets the socket connection resources of the current clients.
	 * @return array the client socket connections
	 */
	public static function getConnections() {
		return array_map(function($client) {
			return $client->connection;
		}, Client::$CLIENTS);
	}

}